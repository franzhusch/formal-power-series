/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6df9c55f-fb50-4c4d-9c25-39d155be0188

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of locally smooth function at 0.
-/
/-- A function is locally smooth at 0 if it is smooth in a neighborhood of 0. -/
def LocallySmoothAtZero (f : ℝ → ℝ) : Prop :=
  ∃ s ∈ nhds (0 : ℝ), ContDiffOn ℝ ⊤ f s

/-
The type of functions locally smooth at 0.
-/
/-- The type of functions locally smooth at 0. -/
def LocallySmoothFunctionAtZero := { f : ℝ → ℝ // LocallySmoothAtZero f }

/-
Addition of locally smooth functions.
-/
instance : Add LocallySmoothFunctionAtZero := ⟨fun f g => ⟨f.1 + g.1, by
  -- By definition of LocallySmoothAtZero, there exist neighborhoods $s$ and $t$ of $0$ such that $f$ is smooth on $s$ and $g$ is smooth on $t$.
  obtain ⟨s, hs, hf⟩ := f.2
  obtain ⟨t, ht, hg⟩ := g.2;
  exact ⟨ s ∩ t, Filter.inter_mem hs ht, hf.mono ( Set.inter_subset_left ) |> ContDiffOn.add <| hg.mono ( Set.inter_subset_right ) ⟩⟩⟩

/-
Multiplication of locally smooth functions.
-/
instance : Mul LocallySmoothFunctionAtZero := ⟨fun f g => ⟨f.1 * g.1, by
  -- Let $s$ and $t$ be neighborhoods of $0$ such that $f$ and $g$ are smooth on $s$ and $t$, respectively.
  obtain ⟨s, hs₀, hs⟩ := f.2
  obtain ⟨t, ht₀, ht⟩ := g.2;
  -- The product of two functions that are smooth on $s$ and $t$ respectively is smooth on $s \cap t$.
  have h_prod : ContDiffOn ℝ ⊤ (f.val * g.val) (s ∩ t) := by
    exact ContDiffOn.mul ( hs.mono <| Set.inter_subset_left ) ( ht.mono <| Set.inter_subset_right );
  exact ⟨ s ∩ t, Filter.inter_mem hs₀ ht₀, h_prod ⟩⟩⟩

/-
Zero element of locally smooth functions.
-/
instance : Zero LocallySmoothFunctionAtZero := ⟨⟨0, by
  exact ⟨ Set.univ, Filter.univ_mem, contDiffOn_const ⟩⟩⟩

/-
One element of locally smooth functions.
-/
instance : One LocallySmoothFunctionAtZero := ⟨⟨1, by
  -- The constant function 1 is smooth everywhere, so it is locally smooth at 0.
  use Set.univ; simp [LocallySmoothAtZero];
  exact contDiffOn_const⟩⟩

/-
Negation of locally smooth functions.
-/
instance : Neg LocallySmoothFunctionAtZero := ⟨fun f => ⟨-f.1, by
  rcases f with ⟨ f, hf ⟩;
  exact ⟨ hf.choose, hf.choose_spec.1, hf.choose_spec.2.neg ⟩⟩⟩

/-
The n-th derivative at 0.
-/
/-- The extraction functional E_n(f) = f^(n)(0). -/
noncomputable def E (n : ℕ) (f : LocallySmoothFunctionAtZero) : ℝ :=
  iteratedDeriv n f.1 0

/-
The homomorphism phi maps a locally smooth function to its Taylor series at 0.
-/
open PowerSeries

/-- The homomorphism φ from locally smooth functions to formal power series. -/
noncomputable def phi (f : LocallySmoothFunctionAtZero) : PowerSeries ℝ :=
  PowerSeries.mk (fun n => E n f / n.factorial)

/-
phi is not injective.
-/
theorem phi_not_injective : ¬ Function.Injective phi := by
  unfold phi;
  unfold Function.Injective;
  norm_num [ PowerSeries.ext_iff ];
  refine' ⟨ ⟨ fun x => if x = 1 then 1 else 0, _ ⟩, ⟨ fun x => 0, _ ⟩, _, _ ⟩;
  all_goals norm_num [ LocallySmoothAtZero, E ];
  refine' ⟨ Set.Ioo ( -1 ) 1, Ioo_mem_nhds ( by norm_num ) ( by norm_num ), _ ⟩;
  exact ContDiffOn.congr ( contDiffOn_const ) fun x hx => if_neg hx.2.ne;
  exact ⟨ Set.univ, Filter.univ_mem, contDiffOn_const ⟩;
  · intro n; rw [ iteratedDeriv_eq_iterate ] ; rw [ iteratedDeriv_eq_iterate ] ; norm_num [ div_eq_mul_inv ] ;
    induction n <;> simp_all +decide [ Function.iterate_fixed ];
    rw [ show deriv ( fun x : ℝ => if x = 1 then ( 1 : ℝ ) else 0 ) = fun x => 0 from _ ] ; norm_num [ Function.iterate_fixed ];
    ext x; by_cases hx : x = 1 <;> norm_num [ hx ];
    · exact IsLocalMax.deriv_eq_zero ( Filter.Eventually.of_forall fun x => by aesop );
    · exact HasDerivAt.deriv ( hasDerivAt_const _ _ |> HasDerivAt.congr_of_eventuallyEq <| by filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) hx ] with y hy using if_neg hy );
  · exact ne_of_apply_ne ( fun f => f.1 1 ) ( by norm_num )

/-
LocallySmoothFunctionAtZero is a commutative ring.
-/
def LocallySmoothSet : Set (ℝ → ℝ) := { f | LocallySmoothAtZero f }

def LocallySmoothSubring : Subring (ℝ → ℝ) :=
  { carrier := LocallySmoothSet
    mul_mem' := by
      intro f g hf hg
      obtain ⟨s, hs, hf⟩ := hf
      obtain ⟨t, ht, hg⟩ := hg
      use s ∩ t
      refine ⟨Filter.inter_mem hs ht, ?_⟩
      exact ContDiffOn.mul (hf.mono Set.inter_subset_left) (hg.mono Set.inter_subset_right)
    one_mem' := by
      use Set.univ
      refine ⟨Filter.univ_mem, contDiffOn_const⟩
    add_mem' := by
      intro f g hf hg
      obtain ⟨s, hs, hf⟩ := hf
      obtain ⟨t, ht, hg⟩ := hg
      use s ∩ t
      refine ⟨Filter.inter_mem hs ht, ?_⟩
      exact ContDiffOn.add (hf.mono Set.inter_subset_left) (hg.mono Set.inter_subset_right)
    zero_mem' := by
      use Set.univ
      refine ⟨Filter.univ_mem, contDiffOn_const⟩
    neg_mem' := by
      intro f hf
      obtain ⟨s, hs, hf⟩ := hf
      use s
      refine ⟨hs, hf.neg⟩ }

instance : CommRing LocallySmoothFunctionAtZero :=
  show CommRing { f // f ∈ LocallySmoothSubring } from inferInstance

/-
General Leibniz Rule for iterated derivatives.
-/
lemma iteratedDeriv_mul {n : ℕ} {f g : ℝ → ℝ} {x : ℝ}
    (hf : ContDiffAt ℝ n f x) (hg : ContDiffAt ℝ n g x) :
    iteratedDeriv n (f * g) x = ∑ k ∈ Finset.range (n + 1), n.choose k * iteratedDeriv k f x * iteratedDeriv (n - k) g x := by
      -- Let's choose any two functions $f$ and $g$ that are $C^n$ at $x$.
      set f' : ℝ → ℝ := fun x => f x
      set g' : ℝ → ℝ := fun x => g x;
      have h_cont_diff : ∃ U : Set ℝ, IsOpen U ∧ x ∈ U ∧ ContDiffOn ℝ n f' U ∧ ContDiffOn ℝ n g' U := by
        have := hf.eventually ( by norm_num );
        have := hg.eventually ( by norm_num );
        rw [ eventually_nhds_iff ] at *;
        obtain ⟨ U, hU₁, hU₂, hU₃ ⟩ := ‹∃ t : Set ℝ, ( ∀ y ∈ t, ContDiffAt ℝ ( n : ℕ∞ ) f y ) ∧ IsOpen t ∧ x ∈ t›; obtain ⟨ V, hV₁, hV₂, hV₃ ⟩ := ‹∃ t : Set ℝ, ( ∀ y ∈ t, ContDiffAt ℝ ( n : ℕ∞ ) g y ) ∧ IsOpen t ∧ x ∈ t›; exact ⟨ U ∩ V, hU₂.inter hV₂, ⟨ hU₃, hV₃ ⟩, fun y hy => hU₁ y hy.1 |> ContDiffAt.contDiffWithinAt, fun y hy => hV₁ y hy.2 |> ContDiffAt.contDiffWithinAt ⟩ ;
      obtain ⟨ U, hU₁, hU₂, hU₃, hU₄ ⟩ := h_cont_diff;
      have h_leibniz : ∀ m ≤ n, ∀ x ∈ U, iteratedDeriv m (f' * g') x = ∑ k ∈ Finset.range (m + 1), Nat.choose m k * iteratedDeriv k f' x * iteratedDeriv (m - k) g' x := by
        intro m hm;
        induction' m with m ih;
        · aesop;
        · -- Apply the product rule to the (m+1)-th derivative.
          have h_prod_rule : ∀ x ∈ U, deriv (fun x => ∑ k ∈ Finset.range (m + 1), Nat.choose m k * iteratedDeriv k f' x * iteratedDeriv (m - k) g' x) x = ∑ k ∈ Finset.range (m + 1), Nat.choose m k * iteratedDeriv (k + 1) f' x * iteratedDeriv (m - k) g' x + ∑ k ∈ Finset.range (m + 1), Nat.choose m k * iteratedDeriv k f' x * iteratedDeriv (m - k + 1) g' x := by
            intro x hx;
            have h_prod_rule : ∀ k ∈ Finset.range (m + 1), DifferentiableAt ℝ (fun x => iteratedDeriv k f' x) x ∧ DifferentiableAt ℝ (fun x => iteratedDeriv (m - k) g' x) x := by
              intro k hk;
              have h_diff : ∀ k ≤ n, ContDiffOn ℝ (↑(n - k)) (iteratedDeriv k f') U ∧ ContDiffOn ℝ (↑(n - k)) (iteratedDeriv k g') U := by
                intro k hk;
                induction' k with k ih;
                · aesop;
                · have := ih ( Nat.le_of_succ_le hk );
                  have h_diff : ContDiffOn ℝ (↑(n - k - 1)) (deriv (iteratedDeriv k f')) U ∧ ContDiffOn ℝ (↑(n - k - 1)) (deriv (iteratedDeriv k g')) U := by
                    rcases n : n - k with ( _ | n ) <;> simp_all +decide [ Nat.sub_sub, contDiffOn_succ_iff_deriv_of_isOpen ];
                    omega;
                  simp_all +decide [ iteratedDeriv_succ ];
                  exact h_diff;
              have := h_diff k ( by linarith [ Finset.mem_range.mp hk ] );
              have := this.1.differentiableOn ( by norm_num; linarith [ Finset.mem_range.mp hk, Nat.sub_add_cancel ( by linarith [ Finset.mem_range.mp hk ] : k ≤ n ) ] );
              have := h_diff ( m - k ) ( by linarith [ Finset.mem_range.mp hk, Nat.sub_le m k ] ) |>.2.differentiableOn ( by norm_num; linarith [ Finset.mem_range.mp hk, Nat.sub_le m k, Nat.sub_add_cancel ( by linarith [ Finset.mem_range.mp hk, Nat.sub_le m k ] : m - k ≤ n ) ] );
              exact ⟨ ‹DifferentiableOn ℝ ( iteratedDeriv k f' ) U›.differentiableAt ( hU₁.mem_nhds hx ), ‹DifferentiableOn ℝ ( iteratedDeriv ( m - k ) g' ) U›.differentiableAt ( hU₁.mem_nhds hx ) ⟩;
            norm_num [ ← mul_assoc, ← Finset.sum_add_distrib, h_prod_rule ];
            convert HasDerivAt.deriv ( HasDerivAt.sum fun i hi => ?_ ) using 1;
            congr! 1;
            rotate_left;
            use fun i x => ( m.choose i : ℝ ) * iteratedDeriv i f' x * iteratedDeriv ( m - i ) g' x;
            · convert HasDerivAt.mul ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( h_prod_rule i hi |>.1.hasDerivAt ) ) ( h_prod_rule i hi |>.2.hasDerivAt ) using 1 ; ring;
              norm_num [ add_comm 1, iteratedDeriv_succ ];
              ring;
            · exact?;
          intro x hx;
          rw [ iteratedDeriv_succ ];
          convert h_prod_rule x hx using 1;
          · exact Filter.EventuallyEq.deriv_eq ( Filter.eventuallyEq_of_mem ( hU₁.mem_nhds hx ) fun y hy => ih ( Nat.le_of_succ_le hm ) y hy );
          · rw [ Finset.sum_range_succ, Finset.sum_range_succ' ];
            rw [ Finset.sum_range_succ, Finset.sum_range_succ' ];
            simp +decide [ Nat.choose_succ_succ, add_comm, add_left_comm, add_assoc, Finset.sum_add_distrib ];
            rw [ ← Finset.sum_add_distrib ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ show 1 + ( m - ( i + 1 ) ) = m - i from by linarith [ Nat.sub_add_cancel ( show i + 1 ≤ m from by linarith [ Finset.mem_range.mp hi ] ), Nat.sub_add_cancel ( show i ≤ m from by linarith [ Finset.mem_range.mp hi ] ) ] ] ; ring;
      exact h_leibniz n le_rfl x hU₂

/-
Iterated derivative of the constant function 1.
-/
lemma iteratedDeriv_const_one {n : ℕ} {x : ℝ} :
    iteratedDeriv n (fun _ : ℝ => (1 : ℝ)) x = if n = 0 then 1 else 0 := by
      cases n <;> simp +decide [ iteratedDeriv_succ' ];
      simp +decide [ iteratedDeriv ]

/-
phi maps 1 to 1.
-/
theorem phi_map_one : phi 1 = 1 := by
  ext; simp [phi];
  unfold E;
  erw [ iteratedDeriv_const_one ] ; aesop

/-
phi preserves multiplication.
-/
theorem phi_map_mul (f g : LocallySmoothFunctionAtZero) : phi (f * g) = phi f * phi g := by
  -- By definition of $\phi$, we know that
  unfold phi;
  -- By definition of $E$, we know that $E_n(f * g) = \sum_{k=0}^n \binom{n}{k} E_k(f) E_{n-k}(g)$.
  have h_E_mul : ∀ n, E n (f * g) = ∑ k ∈ Finset.range (n + 1), Nat.choose n k * E k f * E (n - k) g := by
    intro n;
    -- By definition of $E$, we know that $E_n(f * g) = \frac{d^n}{dx^n}(f * g)(0)$.
    have h_E_def : E n (f * g) = iteratedDeriv n (f.1 * g.1) 0 := by
      exact?;
    rw [ h_E_def, iteratedDeriv_mul ];
    · rfl;
    · have := f.2;
      obtain ⟨ s, hs₁, hs₂ ⟩ := this;
      exact hs₂.contDiffAt ( by simpa using hs₁ ) |> ContDiffAt.of_le <| by norm_num;
    · have := g.2;
      obtain ⟨ s, hs ⟩ := this;
      exact hs.2.contDiffAt ( by aesop ) |> ContDiffAt.of_le <| by aesop;
  ext n; simp +decide [ h_E_mul, PowerSeries.coeff_mul ] ; ring;
  rw [ add_comm, Finset.sum_mul ];
  rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => E i f * ( i.factorial : ℝ ) ⁻¹ * E j g * ( j.factorial : ℝ ) ⁻¹ ];
  refine Finset.sum_congr rfl fun i hi => ?_;
  rw [ Nat.cast_choose ] <;> try linarith [ Finset.mem_range.mp hi ];
  simp +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Nat.factorial_ne_zero ]

/-
phi maps 0 to 0.
-/
theorem phi_map_zero : phi 0 = 0 := by
  refine' PowerSeries.ext fun n => _;
  unfold phi;
  unfold E; norm_num;
  cases n <;> norm_num [ iteratedDeriv_succ ];
  · exact?;
  · erw [ iteratedDeriv_eq_iterate ];
    erw [ Function.iterate_fixed ];
    · erw [ deriv_const ] ; norm_num;
    · exact funext fun _ => deriv_const _ _

/-
phi preserves addition.
-/
theorem phi_map_add (f g : LocallySmoothFunctionAtZero) : phi (f + g) = phi f + phi g := by
  unfold phi;
  ext n;
  unfold E; norm_num; ring;
  rw [ ← mul_add, ← iteratedDeriv_add ];
  · exact mul_comm _ _;
  · obtain ⟨ s, hs, hf ⟩ := f.2;
    exact hf.contDiffAt ( by aesop ) |> ContDiffAt.of_le <| by aesop;
  · -- By definition of $LocallySmoothFunctionAtZero$, we know that $g$ is smooth in a neighborhood of $0$.
    obtain ⟨s, hs₁, hs₂⟩ := g.2;
    exact hs₂.contDiffAt ( by simpa using hs₁ ) |> ContDiffAt.of_le <| by simpa;

/-
phi is a ring homomorphism.
-/
/-- The ring homomorphism from locally smooth functions to formal power series. -/
noncomputable def phiRingHom : LocallySmoothFunctionAtZero →+* PowerSeries ℝ where
  toFun := phi
  map_one' := phi_map_one
  map_mul' := phi_map_mul
  map_zero' := phi_map_zero
  map_add' := phi_map_add

/-
Checking for ContDiffBump.
-/
#check ContDiffBump

/-
Checking for HasContDiffBump instance and ContDiffBump definition.
-/
#synth HasContDiffBump ℝ
#print ContDiffBump

/-
Definition of smoothBump.
-/
/-- A smooth bump function equal to 1 on [-1, 1] and 0 outside (-2, 2). -/
noncomputable def smoothBump : ℝ → ℝ :=
  let b : ContDiffBump (0 : ℝ) := ⟨1, 2, by norm_num, by norm_num⟩
  b

/-
Checking ContDiffBump properties.
-/
#check ContDiffBump.one_of_mem_closedBall
#check ContDiffBump.support_eq
#check ContDiffBump.nonneg
#check ContDiffBump.le_one

/-
Definitions for Borel's Lemma construction.
-/
/-- A sequence of scaling factors for Borel's Lemma. -/
noncomputable def borelLambda (a : ℕ → ℝ) (n : ℕ) : ℝ :=
  max 1 (2 * n * (1 + |a n|)) -- Heuristic choice

/-- The term in the Borel sum. -/
noncomputable def borelTerm (a : ℕ → ℝ) (n : ℕ) (x : ℝ) : ℝ :=
  (a n / n.factorial) * x^n * smoothBump (borelLambda a n * x)

/-- The function constructed for Borel's Lemma. -/
noncomputable def borelFun (a : ℕ → ℝ) (x : ℝ) : ℝ :=
  ∑' n, borelTerm a n x

/-
Relating smoothBump to a ContDiffBump object.
-/
/-- The underlying ContDiffBump object for smoothBump. -/
noncomputable def myBump : ContDiffBump (0 : ℝ) := ⟨1, 2, by norm_num, by norm_num⟩

lemma smoothBump_eq_myBump : smoothBump = myBump := rfl

/-
myBump has compact support.
-/
lemma myBump_hasCompactSupport : HasCompactSupport myBump :=
  ContDiffBump.hasCompactSupport myBump


#check iteratedDeriv
#check PowerSeries
#check PowerSeries.coeff

#check borelFun
#check smoothBump
#check myBump
#check borelLambda
#check borelTerm

/-
The function f(x) = e^{-1/x^2} for x ≠ 0, 0 for x = 0.
-/
/-- The counterexample function f(x) = e^{-1/x^2} for x ≠ 0, 0 for x = 0. -/
noncomputable def counterExample (x : ℝ) : ℝ := expNegInvGlue (x^2)

#check expNegInvGlue.contDiff
#check ContDiff.comp
#check contDiff_id
#check ContDiff.pow

/-
The counterexample function is the composition of `expNegInvGlue` and the squaring function.
-/
lemma counterExample_eq_comp : counterExample = expNegInvGlue ∘ (fun x => x^2) := rfl

/-
The squaring function is smooth.
-/
lemma smooth_sq : ContDiff ℝ ⊤ (fun x : ℝ => x^2) := by
  exact contDiff_id.pow 2
